#include "pin.H"
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "xed-category-enum.h"
#include <fstream> // For file operations
#include <unordered_set>
#include <random>//
#include <chrono>//
#include <sys/mman.h>
#include <thread>

using namespace std;
using namespace std::chrono;
#define LOGOUT std::cout
std::ofstream injection_commands;

KNOB<BOOL> KnobInjectMem(KNOB_MODE_WRITEONCE, "pintool", "inject_only_mem", "0", "Enable memory injection (1=yes, 0=no)");
PIN_LOCK globalLock;
PIN_LOCK pinLock;
/*
int generateRandomNumber() {
    // Seed with a combination of steady clock and current time for better randomness
    static std::mt19937 generator(
        std::chrono::steady_clock::now().time_since_epoch().count()
    );

    // Define the range of random numbers (e.g., 1 to 100)
    std::uniform_int_distribution<int> distribution(1, 100);

    return distribution(generator);
}
*/

int seed=15;
int generateRandomNumber(int seed1) {
    // Παράμετροι του LCG (Numerical Recipes)
    seed = (1664525 * seed1 + 1013904223) % 0xFFFFFFFF;

    // Περιορισμός στο διάστημα [1, 100]
    return 1 + (seed1 % 100);
}


/**
*Function from  https://github.com/DependableSystemsLab/pinfi/blob/master/utils.cpp#L4
*System routines injections guide program execution to segmentation faults
*SDC are undetectable and make program work like nothing happened
*/
bool isValidInst(INS ins) {
/**
 * IMPORTANT: This is to make sure fault injections are done at the .text
 * of the compiled code, instead of at libraries or .init/.fini sections
 */
  if (!RTN_Valid(INS_Rtn(ins))) { // some library instructions do not have rtn !?
    LOG("Invalid RTN " + INS_Disassemble(ins) + "\n");
    return false;
  }

  if (!IMG_IsMainExecutable(SEC_Img(RTN_Sec(INS_Rtn(ins))))) {
    //LOG("Libraries " + IMG_Name(SEC_Img(RTN_Sec(INS_Rtn(ins)))) + "\n");
    return false;
  }
  if (SEC_Name(RTN_Sec(INS_Rtn(ins))) != ".text") {
    //LOG("Section: " + SEC_Name(RTN_Sec(INS_Rtn(ins))) + "\n");
    return false;
  }
  std::string rtnname = RTN_Name(INS_Rtn(ins));
  if (rtnname.find("__libc") == 0 || rtnname.find("_start") == 0 ||
      rtnname.find("call_gmon_start") == 0 || rtnname.find("frame_dummy") == 0 ||
      rtnname.find("__do_global") == 0 || rtnname.find("__stat") == 0) {
    return false;
  }
  LOG("Exe " + RTN_Name(INS_Rtn(ins)) + "\n");

return true;
}



struct ThreadData {////BAZO TO DIKO TOU SEED
    bool inject;
//    bool print;
    int queryId;
    int seed;
    std::ofstream* outFile;
    ADDRINT memEa;
    UINT32 memSize;
    bool    hasMemInfo;   // σημαία ότι έχει μπει info
};

static TLS_KEY tls_key;


VOID ThreadStart(THREADID tid, CONTEXT* ctxt, INT32 flags, VOID* v) {
    ThreadData* data = new ThreadData();
    data->inject = false;
  //  data->print = false;
    data->queryId = 0;
    data->seed = 42;
    std::string filename = "Outfile_inj_" + std::to_string(tid) + ".txt";
    data->outFile = new std::ofstream(filename.c_str());
    data->hasMemInfo = false;
    PIN_SetThreadData(tls_key, data, tid);
}

VOID ThreadFini(THREADID tid, const CONTEXT* ctxt, INT32 code, VOID* v) {
    ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
    if (tdata) {
        if (tdata->outFile) {
            tdata->outFile->close();
            delete tdata->outFile;
        }
        delete tdata;
    }
    //delete data;
}
/*
// Analysis function που θέτει το flag σε true (εισαγωγή στο window)
// Θα κληθεί μετά την εκτέλεση της FaultInjectionBegin
VOID SetInjectTrue(THREADID tid) {
    ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
    tdata->inject = true;
}

// Analysis function που θέτει το flag σε false (έξοδος από το window)
// Θα κληθεί πριν την εκτέλεση της FaultInjectionEnd
VOID SetInjectFalse(THREADID tid) {
    ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
    tdata->inject = false;
}

// Callback που "interpose" την BeginRequest και αποθηκεύει το query id στο TLS
VOID BeginRequestInterpose(int query_id, THREADID tid)
{
    // Αποθήκευση του query id για το τρέχον thread
    ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
    tdata->queryId = query_id;
    tdata->seed = query_id;
    // printf("Thread %u finished query with id: %d\n", tid, query_id);
}

VOID RoutineInstrumentation(RTN rtn, VOID* v) {
    std::string name = RTN_Name(rtn);
    // std::cout << "ROUTINE :" << RTN_Name(rtn) << std::endl; // Debug output
    if (name == "FaultInjectionBegin") {
        //std::cout << "Found FaultInjectionBegin" << std::endl; // Debug output
        RTN_Open(rtn);
        // Μετά την FaultInjectionBegin θέτουμε το flag σε true
        RTN_InsertCall(rtn, IPOINT_AFTER, (AFUNPTR)SetInjectTrue,
            IARG_THREAD_ID, IARG_END);
        RTN_Close(rtn);
    }
    else if (name == "FaultInjectionEnd") {
        // std::cout << "Found FaultInjectionEnd" << std::endl; // Debug output
        RTN_Open(rtn);
        // Πριν την FaultInjectionEnd θέτουμε το flag σε false
        RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)SetInjectFalse,
            IARG_THREAD_ID, IARG_END);
        RTN_Close(rtn);
    }
    else if (name == "FaultInjectionBegin_parent") {
        // std::cout << "Found FaultInjectionEnd" << std::endl; // Debug output
        RTN_Open(rtn);
        // Πριν την FaultInjectionEnd θέτουμε το flag σε false
        RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)SetInjectTrue,
            IARG_THREAD_ID, IARG_END);
        RTN_Close(rtn);
    }
    else if (name == "FaultInjectionEnd_parent") {
        // std::cout << "Found FaultInjectionEnd" << std::endl; // Debug output
        RTN_Open(rtn);
        // Πριν την FaultInjectionEnd θέτουμε το flag σε false
        RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)SetInjectFalse,
            IARG_THREAD_ID, IARG_END);
        RTN_Close(rtn);
    }
    if (RTN_Name(rtn) == "QueryBegins")
    {
        RTN_Open(rtn);
        // Εισάγουμε κλήση πριν την εκτέλεση της BeginRequest
        // IARG_FUNCARG_ENTRYPOINT_VALUE, 0 παίρνει την πρώτη παράμετρο (query_id)
        // IARG_THREAD_ID δίνει το id του τρέχοντος thread
        RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)BeginRequestInterpose,
            IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
            IARG_THREAD_ID,
            IARG_END);
        RTN_Close(rtn);
    }
}
*/

// Function to check if an instruction belongs to arithmetic or logic operations(ALU)
// https://github.com/jingpu/pintools/blob/master/extras/xed2-ia32/include/xed-category-enum.h
bool IsArithmeticLogicInstruction(INS ins) {
    xed_category_enum_t category = static_cast<xed_category_enum_t>(INS_Category(ins));
    return category == XED_CATEGORY_LOGICAL || //and,or,xor
    category == XED_CATEGORY_BITBYTE || //byte oriented instr
    category == XED_CATEGORY_ROTATE ||
    category == XED_CATEGORY_SHIFT || //shl,shr

//    category == XED_CATEGORY_BMI1 || //Bit Manipulation Instruction
//    category == XED_CATEGORY_BMI2 ||
    category == XED_CATEGORY_X87_ALU || //ALU εντολές του x87 FPU
    category == XED_CATEGORY_FMA4 ||
    category == XED_CATEGORY_FP16 ||
    category == XED_CATEGORY_VFMA||
    category ==XED_CATEGORY_BINARY|| //ADD,SYB,MUL
    category ==XED_CATEGORY_LZCNT||//ALU-based counting instructions (POPCNT, LZCNT)
    category ==XED_CATEGORY_SSE||
    category ==XED_CATEGORY_LOGICAL_FP;
 //   category ==XED_CATEGORY_CONVERT||
  //  category ==XED_CATEGORY_SETCC;
//CONVERT,SETCC
}




VOID FI_InjectFault_Mem(const string *disasm,VOID * ip,THREADID tid)
{

    PIN_GetLock(&globalLock, tid);
    if ((rand() % 100) >=70)return; // 30% πιθανότητα
    PIN_ReleaseLock(&globalLock);
      ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
  //  if (tdata && (tdata->inject)) {
    // Identify the routine containing this instruction
    if (!tdata->hasMemInfo) {
        delete disasm;
        return;
    }
    ADDRINT memp   = tdata->memEa;
    UINT32 size  = tdata->memSize;
    tdata->hasMemInfo = false;  // καταναλώνουμε το info
        PIN_LockClient();
        RTN rtn = RTN_FindByAddress(reinterpret_cast<ADDRINT>(ip));
        PIN_UnlockClient();
        std::string routineName = RTN_Valid(rtn) ? RTN_Name(rtn) : std::string("<unknown>");   
        PIN_GetLock(&globalLock, tid);
        injection_commands << "[Thread " << tid << "] Routine: " << routineName <<" Instruction:"<< disasm->c_str()<<" Injection at MEMORY instruction: 0x" << std::hex << ip
        << ", Memory: " << std::hex << memp
        << ", Original Value: 0x" << std::hex << (*((int*)memp));// << std::endl;
        PIN_ReleaseLock(&globalLock);
        UINT8* temp_p = (UINT8*) memp;
        PIN_GetLock(&globalLock, tid);
       //tdata->seed=generateRandomNumber(tdata->seed);
        UINT32 inject_bit = generateRandomNumber(seed) % (size * 8/* bits in one byte*/);
        PIN_ReleaseLock(&globalLock);
        UINT32 byte_num = inject_bit / 8;
        UINT32 offset_num = inject_bit % 8;

        *(temp_p + byte_num) = *(temp_p + byte_num) ^ (1U << offset_num);

        PIN_GetLock(&globalLock, tid);
        injection_commands
           << ", Mask: 0x" << std::hex << (1U << offset_num)
           << ", Injected Value: 0x" << std::hex << (*((int*)memp))
           << std::endl;
        PIN_ReleaseLock(&globalLock);
    delete disasm;
    //}
}

// Injects a single bit flip into the specified register
VOID InjectBitFlip(ADDRINT ip, UINT32 regIndex, REG reg, CONTEXT *ctxt) {
    if(REG_valid(reg)){
    reg = REG_FullRegName(reg);
    ADDRINT regValue = PIN_GetContextReg(ctxt, reg); // Get the current value of the register
    UINT32 injectBit = generateRandomNumber(seed) % (sizeof(UINT32) * 8); // MOST SDCs FOUND ON LEAST SIGNIFICANT BITS(UINT32)
    ADDRINT mask = 1UL << injectBit; // Create a mask for the bit flip
    ADDRINT injectedValue = regValue ^ mask; // Apply the bit flip
    PIN_SetContextReg(ctxt, reg, injectedValue); // Update the register with the new value

    // Log the details of the injection// LOGOUT
    injection_commands << "Injection at instruction: 0x" << std::hex << ip
           << ", Register: " << REG_StringShort(reg)
           << ", Original Value: 0x" << std::hex << regValue
           << ", Mask: 0x" << std::hex << mask
           << ", Injected Value: 0x" << std::hex << injectedValue
           << std::endl;
    PIN_ExecuteAt(ctxt);
 }
}



// Instruments write registers of each instruction for fault injection
VOID InstructionInstrumentation(INS ins, VOID *v) {
// Check if the instruction belongs to arithmetic or logic
   ///////////////////////////////////////////////////////////////////////////////////////////////////
   //if (!isValidInst(ins))
     //   return;
   ///////////////////////////////////////////////////////////////////////////////////////////////////

    if (!isValidInst(ins))
        return;
    if (!(IsArithmeticLogicInstruction(ins))) // Select a r>) {
        return; // Skip non-arithmetic/logic instructions
    if (KnobInjectMem.Value() == 1 && INS_IsMemoryWrite(ins)) {

//       std::string *disasm = new std::string( INS_Disassemble(ins) );
        // 1) Στο IPOINT_BEFORE αποθηκεύουμε EA & size στο ThreadData
        INS_InsertCall(
            ins, IPOINT_BEFORE, (AFUNPTR)+[](
                THREADID tid,
                ADDRINT ea,
                UINT32 size) {
              auto *td = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
              td->memEa     = ea;
              td->memSize   = size;
              td->hasMemInfo= true;
            },
            IARG_THREAD_ID,
            IARG_MEMORYWRITE_EA,
            IARG_MEMORYWRITE_SIZE,
            IARG_END
        );

        // 2) Στο IPOINT_AFTER κάνουμε το fault‐injection,
        //    διαβάζοντας EA & size από το ThreadData
        INS_InsertCall(
            ins, IPOINT_AFTER, AFUNPTR(FI_InjectFault_Mem),
            IARG_PTR,        new std::string(INS_Disassemble(ins)),
            IARG_ADDRINT,    INS_Address(ins),
            IARG_THREAD_ID,
            IARG_END
        );
      return;
    }
    if (KnobInjectMem.Value()) { //if option is 1 inject only on memomry instructions
      return;
    }

    int numW = INS_MaxNumWRegs(ins); // Get the number of write registers for the instruction
    if (numW == 0) return; // Skip if no write registers are available

    int randW =generateRandomNumber(23) % numW; // Select a random write register
    int i=0;
    REG reg = INS_RegW(ins, randW); // Get the corresponding register
//There are Rflags,stack,flag write registers in some instructions that cant be injected or it will cause segmentation faults
      while(numW > i  && (REG_is_any_app_flags(reg)||(reg == REG_RFLAGS || reg == REG_FLAGS || reg == REG_EFLAGS
||reg == REG_STACK_PTR|| reg == REG_RBP || reg == REG_EBP))){
           randW = (randW + 1) % numW;
           i++;
           if (REG_valid(INS_RegW(ins, randW)))
               reg = INS_RegW(ins, randW);
      }

      if (!REG_valid(reg) || (REG_is_any_app_flags(reg)||(reg == REG_RFLAGS || reg == REG_FLAGS || reg == REG_EFLAGS || reg == REG_STACK_PTR))){
            LOG("!!!!!!!!!REGNOTVALID: inst " + INS_Disassemble(ins) + "!!!!!!!!!!!!!\n");
            return;
      }
    if (REG_is_xmm(reg)||REG_is_ymm(reg)) {return;}
    INS_InsertCall(
        ins, IPOINT_AFTER, (AFUNPTR)InjectBitFlip,
        IARG_INST_PTR, // Pass the instruction pointer
        IARG_UINT32, randW, // Pass the register index
        IARG_UINT32, reg, // Pass the register identifier
        IARG_CONTEXT, // Pass the full execution context
        IARG_END
    );
}
/*
// Record each control-flow instruction to the thread's output file
VOID RecordBranch(ADDRINT ip, BOOL taken, ADDRINT target, THREADID tid){
ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
    if (!tdata || !tdata->outFile) return;
    std::ofstream& out = *(tdata->outFile);
    out << std::hex << ip
        << (taken ? " T" : " N")
        << " -> 0x" << target
        << std::dec << std::endl;
}

// Instrumentation routine: insert call for branches, calls, rets
VOID InstructionInstrumentationBranch(INS ins, VOID *v) {
    if (INS_IsBranch(ins) || INS_IsCall(ins) || INS_IsRet(ins)) {
        INS_InsertCall(
            ins, IPOINT_BEFORE, (AFUNPTR)RecordBranch,
            IARG_INST_PTR,
            IARG_BRANCH_TAKEN,
            IARG_BRANCH_TARGET_ADDR,
            IARG_THREAD_ID,
            IARG_END
        );
    }
}
*/

// Function to execute when the program ends
VOID Fini(INT32 code, VOID *v) {
    LOGOUT << "Finished injection tool!" << std::endl; // Indicate tool termination
}



int main(int argc, char *argv[]) { 
    PIN_InitSymbols(); // Initialize Pin's symbol manager

    if (PIN_Init(argc, argv)) { // Initialize Pin with the given arguments
        std::cerr << "This Pintool does fault injection!" << std::endl;
        return 1; // Exit if initialization fails
    }
    srand(time(NULL)); // seed the randomness once
    PIN_InitLock(&pinLock);
    PIN_InitLock(&globalLock);
    tls_key = PIN_CreateThreadDataKey(NULL);
    // Open the results file for writing
    injection_commands.open("injection_results.txt", std::ios::out | std::ios::trunc);
    if (!injection_commands.is_open()) {
        std::cerr << "Error opening results file!" << std::endl;
        return 1;
    }
    // Εγγραφή callbacks για το ξεκίνημα και το τέλος νημάτων
    PIN_AddThreadStartFunction(ThreadStart, NULL);
    PIN_AddThreadFiniFunction(ThreadFini, NULL);


    // Εγγραφή instrumentation για routines (για την ανίχνευση των ορίων του w>
   // RTN_AddInstrumentFunction(RoutineInstrumentation, NULL);

 //   INS_AddInstrumentFunction(InstructionInstrumentationBranch, NULL);
    INS_AddInstrumentFunction(InstructionInstrumentation, 0); // Register the instrumentation function
    PIN_AddFiniFunction(Fini, 0); // Register the finalization function

    PIN_StartProgram(); // Start the target program execution
    return 0; // Should never reach here
}
