#include "pin.H"
#include <iostream>
#include <fstream>
#include <string>
using std::string;
// Global αρχείο για την καταγραφή των αποτελεσμάτων
std::ofstream OutFile;
// Global μετρητής για συνολικό αριθμό instructions (protected by globalLock)
UINT64 globalInstrCount = 0;
PIN_LOCK globalLock;


// Δομή για την αποθήκευση δεδομένων ανά νήμα
struct ThreadData {
    bool inject;        // Flag: true όταν το νήμα βρίσκεται μέσα στο window
    UINT64 instrCount;  // Μετρητής εντολών που εκτελέστηκαν μέσα στο window
};

static TLS_KEY tls_key; //= INVALID_TLS_KEY;  // Key για το Thread-Local Storage
///////////////////////////////////////////////
// Global container για pointers σε ThreadData (πρέπει να προστατεύεται με lock όταν ενημερώνεται)
//std::vector<ThreadData*> g_threadData;
//PIN_LOCK threadDataLock;


////////////////////////////////////////////////////

// Callback που καλείται όταν ξεκινά ένα νήμα
VOID ThreadStart(THREADID tid, CONTEXT *ctxt, INT32 flags, VOID *v) {
    ThreadData* tdata = new ThreadData();
    tdata->inject = false;     // Αρχικά εκτός window
    tdata->instrCount = 0;
    PIN_SetThreadData(tls_key, tdata, tid);
//
 //   PIN_GetLock(&threadDataLock, tid);/////
 //   g_threadData.push_back(tdata);//////
  //  PIN_ReleaseLock(&threadDataLock);////


   PIN_GetLock(&globalLock, tid);
    OutFile << "Thread " << tid << " starts" << std::endl;
   PIN_ReleaseLock(&globalLock);
}

// Callback που καλείται όταν τελειώνει ένα νήμα
VOID ThreadFini(THREADID tid, const CONTEXT *ctxt, INT32 code, VOID *v) {
    ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
        PIN_GetLock(&globalLock, tid);
    OutFile << "Thread " << tid << " executed " << tdata->instrCount
            << " instructions inside the window." << std::endl;
        PIN_ReleaseLock(&globalLock);
    delete tdata;
}

//////////////////////////////////////////////////////////////
// Global container για pointers σε ThreadData (πρέπει να προστατεύεται με lock όταν ενημερώνεται)


// Internal thread function που κάνει periodic logging.
VOID periodicLogger(VOID* arg)
{
    while (true)
    {
        // Sleep για 5 λεπτά (300 sec * 1000 ms/sec = 300000 ms)
        PIN_Sleep(200000);//300000

        // Κάνουμε κλείδωμα για ασφαλή πρόσβαση στα κοινά δεδομένα.
        PIN_GetLock(&globalLock, PIN_ThreadId());
  //      PIN_GetLock(&threadDataLock, PIN_ThreadId());
        
        //UINT64 mergedCount = 0;
       // for (ThreadData* tdata : g_threadData) {
         //    OutFile << "Periodic log: THREAD COUNT: "<<tdata->instrCount<< std::endl;
      //      mergedCount += tdata->instrCount;
//        }
        // Εδώ μπορείς να καταγράψεις το global counter ή/και να κάνεις
        // iterate σε μια δομή που διατηρεί τα per-thread δεδομένα αν τα έχεις αποθηκεύσει.
        OutFile << "Periodic log: Global instruction count: " << globalInstrCount << std::endl;
    //    PIN_ReleaseLock(&threadDataLock);
        PIN_ReleaseLock(&globalLock);
    }
    // Θα εκτελείται επ' αόριστον, δεν φτάνει ποτέ εδώ.
    return;
}
/////////////////////////////////////////////////////////////


// Analysis function που θέτει το flag σε true (εισαγωγή στο window)
// Θα κληθεί μετά την εκτέλεση της FaultInjectionBegin
VOID SetInjectTrue(THREADID tid) {
    ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
    tdata->inject = true;
}

// Analysis function που θέτει το flag σε false (έξοδος από το window)
// Θα κληθεί πριν την εκτέλεση της FaultInjectionEnd
VOID SetInjectFalse(THREADID tid) {
    ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
    tdata->inject = false;
}


// Routine instrumentation: Εντοπίζει τις routines που ορίζουν το window
VOID RoutineInstrumentation(RTN rtn, VOID *v) {
    std::string name = RTN_Name(rtn);
   // std::cout << "ROUTINE :" << RTN_Name(rtn) << std::endl; // Debug output
    if(name == "FaultInjectionBegin") {
    //std::cout << "Found FaultInjectionBegin" << std::endl; // Debug output
        RTN_Open(rtn);
        // Μετά την FaultInjectionBegin θέτουμε το flag σε true
        RTN_InsertCall(rtn, IPOINT_AFTER, (AFUNPTR)SetInjectTrue,
                       IARG_THREAD_ID, IARG_END);
        RTN_Close(rtn);
    }
    else if(name == "FaultInjectionEnd") {
   // std::cout << "Found FaultInjectionEnd" << std::endl; // Debug output
        RTN_Open(rtn);
        // Πριν την FaultInjectionEnd θέτουμε το flag σε false
        RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)SetInjectFalse,
                       IARG_THREAD_ID, IARG_END);
        RTN_Close(rtn);
    }
}

// Analysis function που μετρά μια instruction εάν το νήμα είναι μέσα στο window
VOID CountInstruction(THREADID tid) {/////, ADDRINT ip, const char* rtnName
    ThreadData* tdata = static_cast<ThreadData*>(PIN_GetThreadData(tls_key, tid));
    if(tdata && tdata->inject) {
//    std::cout << "Found count instruction" << std::endl; // Debug output
        tdata->instrCount++;
//if(tdata->instrCount == 0){OutFile<< std::endl;}
  //    PIN_GetLock(&globalLock, tid);
    //  OutFile << "thread  " << tid << " count :" <<tdata->instrCount;
      //PIN_ReleaseLock(&globalLock);
//        // Μπορείς να καταγράφεις επιπλέον και εδώ αν θέλεις, αλλά χωρίς να ενημερώνεις global counter
  //      PIN_GetLock(&globalLock, tid);
   //     OutFile << "Instruction at 0x" << std::hex << ip 
    //            << " in routine " << rtnName << std::endl;
     //   PIN_ReleaseLock(&globalLock);
//        // Ενημέρωση του global μετρητή με προστασία από race conditions
        PIN_GetLock(&globalLock, tid);  //
        globalInstrCount++;             //
        PIN_ReleaseLock(&globalLock);  //
    }
}

// Instruction instrumentation: Εισάγει κλήση για κάθε εντολή
VOID InstructionInstrumentation(INS ins, VOID *v) {
   if (!RTN_Valid(INS_Rtn(ins))) { // some library instructions do not hav>
     //LOG("Invalid RTN " + INS_Disassemble(ins) + "\n");
      return;
   }
   if (!IMG_IsMainExecutable(SEC_Img(RTN_Sec(INS_Rtn(ins))))) {
      //LOG("Libraries " + IMG_Name(SEC_Img(RTN_Sec(INS_Rtn(ins)))) + "\n");
      return;
   }
  if (SEC_Name(RTN_Sec(INS_Rtn(ins))) != ".text") {
    //LOG("Section: " + SEC_Name(RTN_Sec(INS_Rtn(ins))) + "\n");
    return;
  }
    // Προετοιμάζουμε το όνομα της routine.
    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)CountInstruction,
                   IARG_THREAD_ID,
                  // IARG_INST_PTR,///
                   //IARG_PTR, rtnName,/// 
                   IARG_END);
}


// Global Fini callback: Τυπώνει τον συνολικό αριθμό instructions
VOID Fini(INT32 code, VOID *v) {
    OutFile << "Global instruction count: " << globalInstrCount << std::endl;
    OutFile.close();
}


int main(int argc, char *argv[]) {
    // Αρχικοποίηση του Pin
PIN_InitSymbols();
    if(PIN_Init(argc, argv)) {
        std::cerr << "PIN Initialization failed." << std::endl;
        return -1;
    }  
    // Άνοιγμα αρχείου για την καταγραφή των αποτελεσμάτων
    OutFile.open("instr_count.out");
    
    // Αρχικοποίηση του global lock
    PIN_InitLock(&globalLock);
    
    // Δημιουργία TLS key
    tls_key = PIN_CreateThreadDataKey(NULL);
    
    // Εγγραφή callbacks για το ξεκίνημα και το τέλος νημάτων
    PIN_AddThreadStartFunction(ThreadStart, NULL);
    PIN_AddThreadFiniFunction(ThreadFini, NULL);
    
    // Εγγραφή instrumentation για routines (για την ανίχνευση των ορίων του window)
    RTN_AddInstrumentFunction(RoutineInstrumentation, NULL);
    
    // Εγγραφή instrumentation για κάθε instruction (για καταμέτρηση)
    INS_AddInstrumentFunction(InstructionInstrumentation, NULL);
   
    // Εγγραφή global Fini callback για να τυπωθεί ο συνολικός αριθμός instructions
    PIN_AddFiniFunction(Fini, NULL);
   
    // Εκκίνηση του internal thread για periodic logging (5 λεπτά)
PIN_THREAD_UID threadUid = INVALID_PIN_THREAD_UID;
    PIN_SpawnInternalThread(periodicLogger, 0, 0,&threadUid);
   
    // Έναρξη του προγράμματος υπό τον έλεγχο του Pin
    PIN_StartProgram();
    return 0;
}
